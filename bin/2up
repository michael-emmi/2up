#!/usr/bin/env bash

margin=20
resolution=72
paper=letter

function gsbbox {
  local file=$1
  gs -sDEVICE=bbox -r$resolution -dNOPAUSE -dBATCH $file 2>&1 | grep "%%BoundingBox" | cut -d' ' -f 2-5
}

function filter {
  local file=$1
  local selection=$2
  local outfile=${file/.pdf/.$selection.pdf}
  pdfjam -o $outfile $file $selection > /dev/null 2>&1
  echo $outfile
}

function crop {
  local file=$1
  local bbox=$2
  local outfile=${1/.pdf/.cropped.pdf}

  if [[ -z $bbox ]]
  then
    pdfcrop $file --resolution $resolution --margins $margin $outfile > /dev/null
  else
    pdfcrop $file --resolution $resolution --margins $margin --bbox "$bbox" $outfile > /dev/null
  fi
  echo $outfile
}

function join {
  local files=$@
  local outfile=${1/.pdf/.joined.pdf}
  pdfjoin -o $outfile $files --rotateoversize false --paper $paper > /dev/null 2>&1
  echo $outfile
}

function nup {
  local file=$1
  local outfile=${file/.pdf/.nup.pdf}
  pdfnup -o $outfile $file --paper $paper > /dev/null 2>&1
  echo $outfile
}

function split {
  local file=$1
  local selections=${@:2}
  local outfiles=""

  for selection in $selections
  do
    outfiles+=" $(filter $file $selection)"
  done
  echo $outfiles
}

function bbox {
  local file=$1
  local selection=$2
  gsbbox $(filter $file $selection)
}

function quartiles {
  local numbers="$1"
  local n=$(echo "$numbers" | wc -l)
  echo "$numbers" | sort | sed -n "$((n/4))p; $((n/2))p; $((n/4*3))p"
}

function range {
  local numbers="$1"
  local threshold=5
  local q1
  local q2
  local q3
  read -r q1 q2 q3 <<< $(quartiles "$numbers")
  local diff=$((q3-q1))
  diff=$((diff > threshold ? diff : threshold))
  local bound=$((diff*3))
  echo "$((q2-bound)) $((q2+bound))"
}

function outliers {
  local numbers="$1"
  local min
  local max
  local indices=""
  local index=1
  read -r min max <<< $(range "$numbers")
  for n in $numbers
  do
    if (( n < min || n > max ))
    then
      indices+="$index\n"
    fi
    ((++index))
  done
  echo -e $indices
}

function boxes {
  local file=$1
  gsbbox $file
}

function outlier_boxes {
  local boxes=$1
  local indices=""

  for col in $(seq 1 4)
  do
    indices+="$(outliers "$(echo "$boxes" | cut -f $col -d ' ')")\n"
  done

  echo $(echo -e "$indices" | sort -g | uniq)
}

function get_selections {
  local bound=$1
  local outliers=$2
  local selections=""
  local flags=" -v"
  local polarity="0"
  local head="1"
  for index in $(seq 1 $bound)
  do
    if grep -q $(cut -f $((polarity+1)) -d ' ' <<< "$flags") "\b$index\b" <<< "$outliers"
    then
      if ((index == 1))
      then
        :
      elif ((head == index-1))
      then
        selections+=" $head "
      else
        selections+=" $head-$((index-1))"
      fi
      polarity=$(((polarity+1) % 2))
      head=$index
    fi
  done
  selections+=" $head-"
  echo $selections | xargs
}

function get_keypage {
  local bound=$1
  local excluded=$2

  for index in $(seq 1 $bound)
  do
    if grep -q -v "\b$index\b" <<< "$excluded"
    then
      echo $index
      break
    fi
  done
}

function simple_compose {
  local file=$1
  nup $(crop $file)
}

function complex_compose {
  local file=$1

  echo "computing bounding boxes" >&2
  local boxes=$(boxes $file)
  local pages=$(wc -l <<< "$boxes" | xargs)
  echo "composing $pages pages" >&2

  local outliers=$(outlier_boxes "$boxes")
  echo "outliers: $outliers" >&2

  local keypage=$(get_keypage $pages "$outliers")
  echo "keypage: $keypage" >&2

  local selections=$(get_selections $pages "$outliers")
  echo "selections: $selections" >&2

  local box=$(bbox $in $keypage)
  echo "bounding box: $box" >&2

  echo "splitting selections" >&2
  local splits=$(split $file $selections)
  local cropped=""

  echo "cropping selections" >&2
  for split in $splits
  do
    cropped+=" $(crop "$split" "$box")"
  done

  echo "composing cropped selections" >&2
  nup $(join $cropped)
}

function compose {
  local file=$1

  # simple_compose $file
  complex_compose $(basename $file)
}

function main {
  local in=$1
  local file=$(basename $in)
  local dir=$(mktemp -d)

  trap "rm -rf $dir" EXIT
  cp $in $dir
  pushd $dir > /dev/null
  local composed=$(compose $file)
  popd > /dev/null
  cp $dir/$composed ${file/.pdf/.2up.pdf}
}

set -e
main $@
